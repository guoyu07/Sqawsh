// See: https://java.awsblog.com/post/TxQ4JROAWSCDWU/Managing-Dependencies-in-Gradle-with-AWS-SDK-for-Java-Bill-of-Materials-module-B
buildscript {
    repositories {
        mavenCentral()
        maven { url "https://plugins.gradle.org/m2/" } // For grunt and node plugins
    }
    dependencies {
        classpath "io.spring.gradle:dependency-management-plugin:1.0.1.RELEASE",
                  "com.moowork.gradle:gradle-node-plugin:0.13",
                  "com.moowork.gradle:gradle-grunt-plugin:0.13"
    }
}

apply plugin: "io.spring.dependency-management"
apply plugin: "com.moowork.node"
apply plugin: "com.moowork.grunt"

apply plugin: 'java'
apply plugin: 'eclipse' // Generates Eclipse IDE project files
apply plugin: 'idea' // Generates IntelliJ Idea Community Edition IDE project files
apply plugin: 'project-report'

repositories {
    mavenCentral()
}

dependencyManagement {
    imports {
        // Specify AWS SDK version here.
        mavenBom 'com.amazonaws:aws-java-sdk-bom:1.11.167'
    }
}

sourceSets {
    acceptancetest
    loadtest
}

grunt {
    // Folder containing gruntfile.js
    workDir = file("${project.projectDir}/angularjs")

    // Whether colors should output on the terminal
    colors = true

    // Whether output from Grunt should be buffered - useful when running tasks in parallel
    bufferOutput = false
}

node {
    // Version of node to use.
    version = '6.9.1'
    
    // Folder containing package.json
    workDir = file("${project.projectDir}/angularjs")
    
    // Folder containing node_modules folder
    nodeModulesDir = file("${project.projectDir}/angularjs")
}

// makes sure on each build that grunt is installed
build.dependsOn 'installGrunt'

// processes package.json before running build
build.dependsOn 'npmInstall'

// N.B. We have a separate jmeter configuration here solely so we can create a fat jar with our
// JMeter custom samplers that excludes all JMeter dependencies - as JMeter seems not to like
// loading a jar with these - presumably as they are conflicting with stuff already loaded.
configurations {
    acceptancetestCompile.extendsFrom testCompile
    acceptancetestRuntime.extendsFrom testRuntime
    
    jmeter
    loadtestCompile.extendsFrom jmeter
    loadtestRuntime.extendsFrom loadtestCompile
}

ext.cucumberVersion = '1.2.4'
ext.seleniumVersion = '2.48.2'
ext.hamcrestVersion = '1.3'
ext.junitVersion = '4.12'
ext.jmockVersion = '2.8.0'

// Prevent httpclient dependency version conflict - as it breaks htmlunitdriver.
configurations.all {
    resolutionStrategy {
        force 'org.apache.httpcomponents:httpclient:4.5.1'
    }
}

dependencies {
    compile               'com.amazonaws:aws-java-sdk-api-gateway',
                          'com.amazonaws:aws-lambda-java-core:1.1.0',
                          'com.amazonaws:aws-lambda-java-events:1.1.0',
                          'com.amazonaws:aws-java-sdk-cloudformation',
                          'com.amazonaws:aws-java-sdk-cognitoidp',
                          'com.amazonaws:aws-java-sdk-events',
                          'com.amazonaws:aws-java-sdk-iam',
                          'com.amazonaws:aws-java-sdk-lambda',
                          'com.amazonaws:aws-java-sdk-simpledb',
                          'com.amazonaws:aws-java-sdk-s3',
                          'com.amazonaws:aws-java-sdk-sns',
                          'com.amazonaws:aws-java-sdk-logs',
                          'commons-io:commons-io:2.4',
                          'com.google.guava:guava:19.0',
                          'net.lingala.zip4j:zip4j:1.3.2',
                          'org.apache.velocity:velocity:1.7',
                          'org.apache.commons:commons-lang3:3.2',
                          'org.owasp.encoder:encoder:1.2'

    testCompile           "junit:junit:$junitVersion",
                          "org.hamcrest:hamcrest-core:${hamcrestVersion}",
                          "org.hamcrest:hamcrest-library:${hamcrestVersion}",
                          "org.jmock:jmock:${jmockVersion}",
                          "org.jmock:jmock-junit4:${jmockVersion}"

    acceptancetestCompile "info.cukes:cucumber-java:$cucumberVersion",
                          "info.cukes:cucumber-junit:$cucumberVersion",
                          "info.cukes:cucumber-java8:$cucumberVersion",
                          "info.cukes:cucumber-picocontainer:$cucumberVersion",
                          "io.appium:java-client:3.3.0",
                          'org.picocontainer:picocontainer:2.15',
                          "org.seleniumhq.selenium:selenium-java:$seleniumVersion",
                          "org.seleniumhq.selenium:selenium-firefox-driver:$seleniumVersion",
                          "org.seleniumhq.selenium:selenium-chrome-driver:$seleniumVersion",
                          "org.seleniumhq.selenium:selenium-safari-driver:$seleniumVersion",
                          "org.seleniumhq.selenium:selenium-htmlunit-driver:$seleniumVersion",
                          "org.seleniumhq.selenium:selenium-api:$seleniumVersion"

    jmeter                "org.apache.jmeter:ApacheJMeter_java:3.1"
    loadtestCompile       'com.amazonaws:aws-java-sdk:1.11.123',
                          "com.amazonaws:aws-java-sdk-opensdk:1.11.94",
                          'com.fasterxml.jackson.core:jackson-core:2.8.7',
                          files('build/apigateway-sdk/build/libs/Squash-1.0-SNAPSHOT.jar')
}

task gw(type: Wrapper) {
    gradleVersion = '3.4.1'
    scriptFile = 'gw'
}

task acceptanceTest(type: Test) {
    description = 'Runs the acceptance tests'
    testClassesDir = sourceSets.acceptancetest.output.classesDir
    classpath = sourceSets.acceptancetest.runtimeClasspath
    outputs.upToDateWhen { false }
    dependsOn(test)
}

// Zips of lambda functions to upload to AWS lambda. We have flexibility
// to package all lambdas beneath particular paths into separate zips. The
// layout of each zip is as specified by Amazon. These tasks dump the zips
// in the build/distributions folder, ready for upload to AWS Lambda.
['Squash'].each { targetName -> 
    task "zipLambda${targetName}"(type: Zip) {
        baseName "${targetName}"
        def folderName = "${targetName}".toLowerCase()
        from("${sourceSets.main.output.classesDir}") {
            include "**/${folderName}/**"
            includeEmptyDirs = false
        }
        from processResources
        into('lib') {
           from configurations.runtime // Zip our compile and runtime dependencies
        }
    }
}
task zipAllLambdas(dependsOn: tasks.matching { Task task -> task.name.startsWith("zipLambda")})
zipAllLambdas.dependsOn(classes)
build.dependsOn(zipAllLambdas)

// Zip of our minimised css and js to upload to AWS.
// During stack creation, this will be unzipped into the S3 website bucket.
task zipAngularjsApp(type: Zip) {
    baseName 'AngularjsApp'
    into('app') {
        from('angularjs/dist/') {
            include 'sqawsh.min.js'
            include 'sqawsh.min.css'
        }
        from('angularjs/app/') {
            include '**/*.html'
            // Currently use Bower only for dev
            exclude 'bower_components/**/*.*'
        }
    }
    outputs.upToDateWhen { false }
}

// Minimise our css and js before zipping the app:
// Run the grunt tasks to produce the minimised css
grunt_postcss.dependsOn(grunt_less)
zipAngularjsApp.dependsOn(grunt_postcss)
// Run the grunt tasks to produce the minimised js
grunt_babel.dependsOn(grunt_concat)
grunt_uglify.dependsOn(grunt_babel)
zipAngularjsApp.dependsOn(grunt_uglify)
build.dependsOn(zipAngularjsApp)

// Clean up after grunt when the clean task is run
clean.doFirst {
    delete "${rootDir}/angularjs/dist/"
}

// N.B. LoadTest should have its java api sdk auto-downloaded into place after the
// main stack is created. But aws java sdk does not yet support this. So need to
// download it manually before LoadTest will compile.

// This is jar with only our custom samplers - i.e. excluding their dependencies.
task createJMeterCustomSamplersJar(type: Jar, dependsOn: compileLoadtestJava) {
    archiveName = 'JMeterSqawshCustomSamplers.jar'
    from(sourceSets.loadtest.output.classesDir) {
        include '**/*.class'
    }
    outputs.upToDateWhen { false }
}
if (!project.hasProperty("JMeterCustomSamplersFolder")) {
    // Default folder to copy JMeter custom samplers jar to. JMeter will find jars placed in its lib/ext folder.
    // (This is where 'brew install jmeter' puts it on Mac.)
    ext.JMeterCustomSamplersFolder = "/usr/local/Cellar/jmeter/3.1/libexec/lib/ext"
}
// Better not to clean this task as it will delete entire folder - including other jmeter stuff. Made
// it always out-of-date instead so always copies.
task deployJMeterCustomSamplersJar(type:Copy) {
    description = 'Deploys the JMeter custom samplers jar to the folder in your JMeter installation specified by the JMeterCustomSamplersFolder property (defaults to /usr/local/Cellar/jmeter/3.1/libexec/lib/ext)'
    from createJMeterCustomSamplersJar
    into "$JMeterCustomSamplersFolder"
    outputs.upToDateWhen { false }
}

// The dependencies of our custom samplers are in a separate jar as they get
// deployed to a different folder within the JMeter installation tree.
task createJMeterCustomSamplersDependenciesJar(type: Jar, dependsOn: compileLoadtestJava) {
    archiveName = 'JMeterSqawshCustomSamplersDependencies.jar'
    // Include all dependencies in the jar, except jmeter - which will be provided by
    // JMeter already. (Providing them again here seems to break JMeter.)
    from { (configurations.loadtestRuntime - configurations.jmeter).collect { it.isDirectory() ? it : zipTree(it) } }
    outputs.upToDateWhen { false }
}
if (!project.hasProperty("JMeterCustomSamplersDependenciesFolder")) {
    // Default folder to copy dependencies of JMeter custom samplers jar to. JMeter will find such jars placed in its lib folder.
    // (This is where 'brew install jmeter' puts it on Mac.)
    ext.JMeterCustomSamplersDependenciesFolder = "/usr/local/Cellar/jmeter/3.1/libexec/lib"
}
// Better not to clean this task as it will delete entire folder - including other jmeter stuff. Made
// it always out-of-date instead so always copies.
task deployJMeterCustomSamplersDependenciesJar(type:Copy) {
    description = 'Deploys the JMeter custom samplers dependency jars to the folder in your JMeter installation specified by the JMeterCustomSamplersDependenciesFolder property (defaults to /usr/local/Cellar/jmeter/3.1/libexec/lib)'
    from createJMeterCustomSamplersDependenciesJar
    into "$JMeterCustomSamplersDependenciesFolder"
    outputs.upToDateWhen { false }
}
// Combo task to deploy both jars associated with our custom samplers.
task deployJMeterCustomSamplersAndDependenciesJars() {
    description 'Deploys Jmeter Custom Samplers and their dependencies to the JMeter installation tree.'
    outputs.upToDateWhen { false }
}
deployJMeterCustomSamplersAndDependenciesJars.dependsOn(deployJMeterCustomSamplersJar, deployJMeterCustomSamplersDependenciesJar)

// N.B. This task will work only if the AWS CLI tools are installed
// Pass it an S3 bucketname and a zip revision number and it will upload
// both zip files and the CloudFormation template to the bucket. e.g.:
// ./gw uploadToS3 -PS3ZipBucketName=<BucketName> -PZipRevision=<revision>
if (!project.hasProperty("S3ZipBucketName")) {
    // Default name of S3 bucket to upload to
    ext.S3ZipBucketName = "squashzips"
}
if (!project.hasProperty("ZipRevision")) {
    // Default revision number suffix for lambda zip file
    ext.ZipRevision = 1
}
task uploadAngularjsZipToAws(type: Exec) {
    description 'Uploads the zipped Angularjs app to the S3 bucket specified by the S3ZipBucketName property (defaults to squashzips).'
    commandLine 'aws', 's3', 'cp', 'build/distributions/AngularjsApp.zip', "s3://$S3ZipBucketName/AngularjsApp.zip"
}
uploadAngularjsZipToAws.dependsOn(zipAngularjsApp)

task uploadLambdaZipsToAws(type: Exec) {
    description 'Uploads the zipped lambda code to the S3 bucket specified by the S3ZipBucketName property (defaults to squashzips). Appends an integer suffix specified by the ZipRevision property (defaults to 1).'
    commandLine 'aws', 's3', 'cp', 'build/distributions/Squash.zip', "s3://$S3ZipBucketName/Squash${ZipRevision}.zip"
}
uploadLambdaZipsToAws.dependsOn(zipAllLambdas)

task uploadCloudFormationTemplateToAws(type: Exec) {
    description 'Uploads the cloudformation template to the S3 bucket specified by the S3ZipBucketName property (defaults to squashzips).'
    commandLine 'aws', 's3', 'cp', 'src/main/resources/squash/deployment/templates/Squash.template', "s3://$S3ZipBucketName/Squash.template"
}

// Combo task to Upload both zips and the template
task uploadToS3() {
    description 'Uploads the Angularjs app, the lambda code, and the cloudformation template to S3.'
}
uploadToS3.dependsOn(uploadCloudFormationTemplateToAws, uploadAngularjsZipToAws, uploadLambdaZipsToAws)

build.dependsOn(javadoc)

tasks.withType(Test) {
    reports.html.destination = file("${reporting.baseDir}/${name}")
}

eclipse {
  classpath {
    //you can tweak the classpath of the Eclipse project by adding extra configurations:
    plusConfigurations += [ configurations.acceptancetestCompile, configurations.loadtestCompile ]
  }
}